---
layout: post
title: "Understanding bind"
---

<p>In <a href="{% post_url 2016-03-27-understanding-map %}">Understanding map</a> we learned that implementing
a <code>map</code> function is what we call a <em>Functor</em>. In <a href="{% post_url 2016-03-31-applicative-functors %}">Applicative Functors</a>
we extended that idea with the <code>return</code> and <code>apply</code> function. The next important function in our toolset is
the <code>bind</code> function.</p>
<h2>Monads</h2>
<p>The combination of <code>return</code> and <code>bind</code> is what we call a Monad. But currently
I will not consider this as an introduction to Monads at all. If you heard the <em>Monad</em> term and
search for an introduction to understand what a <em>Monad</em> is you will not find an answer her. If
you already have some basic understanding about the term than this and my two previous blogs
can help to understand the concept. Otherwise if you just try to understand what a <em>Monad</em> is
I recommend the following link to understand the problem:
<a href="http://two-wrongs.com/the-what-are-monads-fallacy">The what are Monads Fallacy</a></p>
<h2>The Problem</h2>
<p>I think it is always good to start with a problem. If we understand a problem first, we usually
have it easier to understand why we are doing something. Currently we have <code>map</code> to upgrade functions with
one argument, with <code>return</code> and <code>apply</code> we could upgrade functions with multiple arguments. So
what is <code>bind</code> supposed to do?</p>
<p>Up to this point we only upgraded functions that had normal unboxed input and output types. We always
faced functions like <code>'a -&gt; 'b</code>, but never functions like <code>'a -&gt; option&lt;'b&gt;</code>, <code>'a -&gt; Async&lt;'b&gt;</code>
or <code>'a -&gt; list&lt;'b&gt;</code>. But in practice, the latter are quite common.</p>
<p>A simple example is a function that tries to parse a <code>string</code> to a <code>float</code>. Because parsing of
a string to a float could fail we usually expect a return type like <code>option&lt;float&gt;</code>. Usually we
create a <code>Double</code> extension for this.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// Note: .NET System.Double is &quot;float&quot;   in F# and &quot;double&quot; in C#.</span>
<span class="c">//       .NET System.Single is &quot;float32&quot; in F# and &quot;float&quot;  in C#.</span>
<span class="k">type</span> <span onmouseout="hideTip(event, 'fs3', 3)" onmouseover="showTip(event, 'fs3', 3)" class="t">Double</span> <span class="k">with</span>
    <span class="k">static</span> <span class="k">member</span> <span onmouseout="hideTip(event, 'fs4', 4)" onmouseover="showTip(event, 'fs4', 4)" class="f">tryParse</span> <span onmouseout="hideTip(event, 'fs5', 5)" onmouseover="showTip(event, 'fs5', 5)" class="i">str</span> <span class="o">=</span>
        <span class="k">match</span> <span onmouseout="hideTip(event, 'fs3', 6)" onmouseover="showTip(event, 'fs3', 6)" class="t">Double</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs6', 7)" onmouseover="showTip(event, 'fs6', 7)" class="f">TryParse</span> <span onmouseout="hideTip(event, 'fs5', 8)" onmouseover="showTip(event, 'fs5', 8)" class="i">str</span> <span class="k">with</span>
        | <span class="k">false</span>,_ <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs7', 9)" onmouseover="showTip(event, 'fs7', 9)" class="p">None</span>
        | <span class="k">true</span>,<span onmouseout="hideTip(event, 'fs8', 10)" onmouseover="showTip(event, 'fs8', 10)" class="i">x</span>  <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs9', 11)" onmouseover="showTip(event, 'fs9', 11)" class="p">Some</span> <span onmouseout="hideTip(event, 'fs8', 12)" onmouseover="showTip(event, 'fs8', 12)" class="i">x</span>
</code></pre></td>
</tr>
</table>
<p>We now have a function <code>Double.tryParse</code> with the signature.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs10', 13)" onmouseover="showTip(event, 'fs10', 13)" class="f">string</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs11', 14)" onmouseover="showTip(event, 'fs11', 14)" class="i">option</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs12', 15)" onmouseover="showTip(event, 'fs12', 15)" class="i">float</span><span class="o">&gt;</span>
</code></pre></td>
</tr>
</table>
<p>I will call such functions <em>Monadic functions</em> from now on. All <em>Monadic functions</em> expect
normal input arguments, but return a boxed type, like <code>option&lt;'a&gt;</code>, <code>list&lt;'a&gt;</code>, <code>Async&lt;'a&gt;</code>
and so on.</p>
<p>The problem with such functions is that we cannot easily upgrade them like other functions. For example,
let's assume we have a <code>option&lt;string&gt;</code>, and now we want to pass this value to <code>Double.tryParse</code>.
As <code>tryParse</code> only expects <code>string</code> we could <code>Option.map</code> <code>tryParse</code> so it could work with
a <code>option&lt;string&gt;</code>.</p>
<p>But <code>map</code> not only adds a <code>option</code> <em>layer</em> to the input, it also adds it to the output. When we
use <code>Option.map</code> on our <code>Double.tryParse</code> function, we get a function that looks like this:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs11', 16)" onmouseover="showTip(event, 'fs11', 16)" class="i">option</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs10', 17)" onmouseover="showTip(event, 'fs10', 17)" class="i">string</span><span class="o">&gt;</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs11', 18)" onmouseover="showTip(event, 'fs11', 18)" class="i">option</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs11', 19)" onmouseover="showTip(event, 'fs11', 19)" class="i">option</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs12', 20)" onmouseover="showTip(event, 'fs12', 20)" class="i">float</span><span class="o">&gt;</span><span class="o">&gt;</span>
</code></pre></td>
</tr>
</table>
<p>The problem is that our <em>output</em> is wrapped two times in the same layer. Now we have a
<em>option containing an option containing a float</em>. But what we really want is just an <code>option&lt;float&gt;</code>.
This is where <code>bind</code> comes into the play. The purpose of <code>bind</code> is to only <em>upgrade</em> the input of a
function because the output of a function already returns an upgraded type. A <code>bind</code> function thus
always have the <em>type-signature</em></p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp">(<span class="o">&#39;</span><span class="i">a</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs11', 21)" onmouseover="showTip(event, 'fs11', 21)" class="i">option</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">b</span><span class="o">&gt;</span>) <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs11', 22)" onmouseover="showTip(event, 'fs11', 22)" class="i">option</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">a</span><span class="o">&gt;</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs11', 23)" onmouseover="showTip(event, 'fs11', 23)" class="i">option</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">b</span><span class="o">&gt;</span>
(<span class="o">&#39;</span><span class="i">a</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs13', 24)" onmouseover="showTip(event, 'fs13', 24)" class="i">list</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">b</span><span class="o">&gt;</span>)   <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs13', 25)" onmouseover="showTip(event, 'fs13', 25)" class="i">list</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">a</span><span class="o">&gt;</span>   <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs13', 26)" onmouseover="showTip(event, 'fs13', 26)" class="i">list</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">b</span><span class="o">&gt;</span>
(<span class="o">&#39;</span><span class="i">a</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs14', 27)" onmouseover="showTip(event, 'fs14', 27)" class="i">Async</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">b</span><span class="o">&gt;</span>)  <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs14', 28)" onmouseover="showTip(event, 'fs14', 28)" class="i">Async</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">a</span><span class="o">&gt;</span>  <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs14', 29)" onmouseover="showTip(event, 'fs14', 29)" class="i">Async</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">b</span><span class="o">&gt;</span>
</code></pre></td>
</tr>
</table>
<h2><code>return</code> once again</h2>
<p>The <code>bind</code> function don't stands on it's own. We also need a <code>return</code> function. But we
already covered this function in <a href="{% post_url 2016-03-31-applicative-functors %}">Applicative Functors</a>.</p>
<h2>Implementing <code>bind</code></h2>
<p>We can implement <code>bind</code> in two different ways. It is good to know both as depending on which type we
have, sometimes the one or the other can be easier.</p>
<ol>
<li>
The obvious way. You directly write a <code>bind</code> function that is similar to <code>map</code>, but instead
of wrapping the output, you just return the output of the function as-is.
</li>
<li>
You first write a <code>join</code>, <code>concat</code> or <code>flatten</code> function (The exact name of such a function
usually depends on the type you have). The idea of such a function is to resolve two
boxed types just into a single box. After this you just <code>map</code> and then <code>join</code> the result
to create <code>bind</code>.
</li>
</ol>
<p>The <code>option</code> type has the advantage that both implementations are easy, so let's look at how we could
implement <code>bind</code> for <code>Option</code> in both ways.</p>
<h3>The direct way</h3>
<p>The <em>direct</em> way can sometimes be nearly identical to <code>map</code>. Let's look at the <code>map</code> and <code>bind</code>
implementation side-by-side.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
<span class="l">8: </span>
<span class="l">9: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs15', 30)" onmouseover="showTip(event, 'fs15', 30)" class="f">mapOption</span> <span onmouseout="hideTip(event, 'fs16', 31)" onmouseover="showTip(event, 'fs16', 31)" class="f">f</span> <span onmouseout="hideTip(event, 'fs17', 32)" onmouseover="showTip(event, 'fs17', 32)" class="i">opt</span> <span class="o">=</span>
    <span class="k">match</span> <span onmouseout="hideTip(event, 'fs17', 33)" onmouseover="showTip(event, 'fs17', 33)" class="i">opt</span> <span class="k">with</span>
    | <span onmouseout="hideTip(event, 'fs7', 34)" onmouseover="showTip(event, 'fs7', 34)" class="p">None</span>   <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs7', 35)" onmouseover="showTip(event, 'fs7', 35)" class="p">None</span>
    | <span onmouseout="hideTip(event, 'fs9', 36)" onmouseover="showTip(event, 'fs9', 36)" class="p">Some</span> <span onmouseout="hideTip(event, 'fs18', 37)" onmouseover="showTip(event, 'fs18', 37)" class="i">x</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs9', 38)" onmouseover="showTip(event, 'fs9', 38)" class="p">Some</span> (<span onmouseout="hideTip(event, 'fs16', 39)" onmouseover="showTip(event, 'fs16', 39)" class="f">f</span> <span onmouseout="hideTip(event, 'fs18', 40)" onmouseover="showTip(event, 'fs18', 40)" class="i">x</span>)

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs19', 41)" onmouseover="showTip(event, 'fs19', 41)" class="f">bindOption</span> <span onmouseout="hideTip(event, 'fs20', 42)" onmouseover="showTip(event, 'fs20', 42)" class="f">f</span> <span onmouseout="hideTip(event, 'fs17', 43)" onmouseover="showTip(event, 'fs17', 43)" class="i">opt</span> <span class="o">=</span>
    <span class="k">match</span> <span onmouseout="hideTip(event, 'fs17', 44)" onmouseover="showTip(event, 'fs17', 44)" class="i">opt</span> <span class="k">with</span>
    | <span onmouseout="hideTip(event, 'fs7', 45)" onmouseover="showTip(event, 'fs7', 45)" class="p">None</span>   <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs7', 46)" onmouseover="showTip(event, 'fs7', 46)" class="p">None</span>
    | <span onmouseout="hideTip(event, 'fs9', 47)" onmouseover="showTip(event, 'fs9', 47)" class="p">Some</span> <span onmouseout="hideTip(event, 'fs18', 48)" onmouseover="showTip(event, 'fs18', 48)" class="i">x</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs20', 49)" onmouseover="showTip(event, 'fs20', 49)" class="f">f</span> <span onmouseout="hideTip(event, 'fs18', 50)" onmouseover="showTip(event, 'fs18', 50)" class="i">x</span>
</code></pre></td>
</tr>
</table>
<p>As you can see, both functions are nearly identical. The only difference is that we just do <code>f x</code> instead
of <code>Some (f x)</code>. We don't need to wrap the output in a <code>Some</code> because our function <code>f</code> already returns
an <code>option</code>. So we just return it's output directly.</p>
<h3>The <code>join</code> way</h3>
<p>The other way is to first implement a new function that can turn a <code>option&lt;option&lt;'a&gt;&gt;</code> just into a
<code>option&lt;'a&gt;</code>. That's also quite easy. We first check our outer-most <code>option</code>. If it is <code>None</code>
we just return <code>None</code>. In the <code>Some</code> case we have another option that we directly return.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs21', 51)" onmouseover="showTip(event, 'fs21', 51)" class="f">joinOption</span> <span onmouseout="hideTip(event, 'fs22', 52)" onmouseover="showTip(event, 'fs22', 52)" class="i">opt</span> <span class="o">=</span>
    <span class="k">match</span> <span onmouseout="hideTip(event, 'fs22', 53)" onmouseover="showTip(event, 'fs22', 53)" class="i">opt</span> <span class="k">with</span>
    | <span onmouseout="hideTip(event, 'fs7', 54)" onmouseover="showTip(event, 'fs7', 54)" class="p">None</span>          <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs7', 55)" onmouseover="showTip(event, 'fs7', 55)" class="p">None</span>
    | <span onmouseout="hideTip(event, 'fs9', 56)" onmouseover="showTip(event, 'fs9', 56)" class="p">Some</span> <span onmouseout="hideTip(event, 'fs23', 57)" onmouseover="showTip(event, 'fs23', 57)" class="i">innerOpt</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs23', 58)" onmouseover="showTip(event, 'fs23', 58)" class="i">innerOpt</span>
</code></pre></td>
</tr>
</table>
<p>Now we create <code>bind</code> by just using <code>map</code> and <code>join</code> the result.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs24', 59)" onmouseover="showTip(event, 'fs24', 59)" class="f">bindOption2</span> <span onmouseout="hideTip(event, 'fs20', 60)" onmouseover="showTip(event, 'fs20', 60)" class="f">f</span> <span onmouseout="hideTip(event, 'fs17', 61)" onmouseover="showTip(event, 'fs17', 61)" class="i">opt</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs21', 62)" onmouseover="showTip(event, 'fs21', 62)" class="f">joinOption</span> (<span onmouseout="hideTip(event, 'fs15', 63)" onmouseover="showTip(event, 'fs15', 63)" class="f">mapOption</span> <span onmouseout="hideTip(event, 'fs20', 64)" onmouseover="showTip(event, 'fs20', 64)" class="f">f</span> <span onmouseout="hideTip(event, 'fs17', 65)" onmouseover="showTip(event, 'fs17', 65)" class="i">opt</span>)
</code></pre></td>
</tr>
</table>
<h3>Simple usage</h3>
<p>Let's test both functions and compare it with a <code>map</code> call.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs25', 66)" onmouseover="showTip(event, 'fs25', 66)" class="i">input1</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs9', 67)" onmouseover="showTip(event, 'fs9', 67)" class="p">Some</span> <span class="s">&quot;abcde&quot;</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs19', 68)" onmouseover="showTip(event, 'fs19', 68)" class="f">bindOption</span>  <span onmouseout="hideTip(event, 'fs3', 69)" onmouseover="showTip(event, 'fs3', 69)" class="t">Double</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs26', 70)" onmouseover="showTip(event, 'fs26', 70)" class="f">tryParse</span>  <span class="c">// None</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs27', 71)" onmouseover="showTip(event, 'fs27', 71)" class="i">input2</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs9', 72)" onmouseover="showTip(event, 'fs9', 72)" class="p">Some</span> <span class="s">&quot;100&quot;</span>   <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs24', 73)" onmouseover="showTip(event, 'fs24', 73)" class="f">bindOption2</span> <span onmouseout="hideTip(event, 'fs3', 74)" onmouseover="showTip(event, 'fs3', 74)" class="t">Double</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs26', 75)" onmouseover="showTip(event, 'fs26', 75)" class="f">tryParse</span>  <span class="c">// Some 100.0</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs28', 76)" onmouseover="showTip(event, 'fs28', 76)" class="i">input3</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs9', 77)" onmouseover="showTip(event, 'fs9', 77)" class="p">Some</span> <span class="s">&quot;200&quot;</span>   <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs15', 78)" onmouseover="showTip(event, 'fs15', 78)" class="f">mapOption</span>   <span onmouseout="hideTip(event, 'fs3', 79)" onmouseover="showTip(event, 'fs3', 79)" class="t">Double</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs26', 80)" onmouseover="showTip(event, 'fs26', 80)" class="f">tryParse</span>  <span class="c">// Some (Some 200.0)</span>
</code></pre></td>
</tr>
</table>
<p>As we can see from the signature. <code>input1</code> and <code>input2</code> are just <code>option&lt;float&gt;</code>
instead of <code>option&lt;option&lt;float&gt;&gt;</code> that a <code>map</code> will return us.</p>
<p>The <code>Option</code> module already contains <code>Option.map</code> and <code>Option.bind</code>, so we don't have to
rewrite those ourselves. As another exercise, let's look at a <code>bind</code> implementation for <code>list</code>.</p>
<h2><code>bind</code> for <code>list</code></h2>
<p>Creating a <code>bind</code> for a <code>list</code> is a case where the first-approach is usually really hard. Let's look
at a <code>map</code> implementation for <code>list</code> first.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs29', 81)" onmouseover="showTip(event, 'fs29', 81)" class="f">mapList</span> <span onmouseout="hideTip(event, 'fs16', 82)" onmouseover="showTip(event, 'fs16', 82)" class="f">f</span> <span onmouseout="hideTip(event, 'fs30', 83)" onmouseover="showTip(event, 'fs30', 83)" class="i">inputList</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs31', 84)" onmouseover="showTip(event, 'fs31', 84)" class="f">folder</span> <span onmouseout="hideTip(event, 'fs18', 85)" onmouseover="showTip(event, 'fs18', 85)" class="i">x</span> <span onmouseout="hideTip(event, 'fs32', 86)" onmouseover="showTip(event, 'fs32', 86)" class="i">xs</span> <span class="o">=</span>
        (<span onmouseout="hideTip(event, 'fs16', 87)" onmouseover="showTip(event, 'fs16', 87)" class="f">f</span> <span onmouseout="hideTip(event, 'fs18', 88)" onmouseover="showTip(event, 'fs18', 88)" class="i">x</span>) <span class="o">::</span> <span onmouseout="hideTip(event, 'fs32', 89)" onmouseover="showTip(event, 'fs32', 89)" class="i">xs</span>
    <span onmouseout="hideTip(event, 'fs33', 90)" onmouseover="showTip(event, 'fs33', 90)" class="t">List</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs34', 91)" onmouseover="showTip(event, 'fs34', 91)" class="f">foldBack</span> <span onmouseout="hideTip(event, 'fs31', 92)" onmouseover="showTip(event, 'fs31', 92)" class="f">folder</span> <span onmouseout="hideTip(event, 'fs30', 93)" onmouseover="showTip(event, 'fs30', 93)" class="i">inputList</span> []
</code></pre></td>
</tr>
</table>
<p><code>Option.bind</code> was really easy as we could directly return what the call to <code>f</code> returned. But for a list
this is not possible. Because in a list we call <code>f</code> multiple times for the input list, and the output
of those are collected into a new list.</p>
<p>Because <code>f</code> is a <em>Monadic function</em> in <code>bind</code> it means every call to <code>f</code> will return a list. If
we add a list to another list, we get a list of list as expected <code>list&lt;list&lt;'a&gt;&gt;</code>. If we try to
return a single <code>list</code> instead, it means we have to loop over the result of <code>f</code> and add its element
to another list.</p>
<p>Solving that problem inside of <code>bind</code> is hard, because <code>list</code> is an <em>immutable</em> data-structure. With a
<em>mutable</em> list (<code>ResizeArray</code>) this operation would be quite easy, as we just could call <code>f x</code> that
returns a <code>list</code> and loop through it and add it to some other list, but with an <em>immutable</em> list we
cannot just add elements to an existing element.</p>
<p>When we really want to solve it in one-go we could use a mutable list like <code>ResizeArray</code>, otherwise
we have to use two nested <code>fold</code> or <code>foldBack</code> calls. Instead of nesting it and turning it in a complex
function it is usually better to just extract those operation into it's own function. So we create
a <code>concat</code> operation first, that can turn a <code>list&lt;list&lt;'a&gt;&gt;</code> just into a single list.</p>
<p>I'm not showing how to implementing <code>concat</code> for <code>list</code>, as the focus is <code>bind</code> not how immutable list
processing works. So for <code>list</code> we usually would prefer just a <code>map</code> and <code>concat</code> implementation for
<code>bind</code>.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs35', 94)" onmouseover="showTip(event, 'fs35', 94)" class="f">bindList</span> <span onmouseout="hideTip(event, 'fs36', 95)" onmouseover="showTip(event, 'fs36', 95)" class="f">f</span> <span onmouseout="hideTip(event, 'fs37', 96)" onmouseover="showTip(event, 'fs37', 96)" class="i">xs</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs33', 97)" onmouseover="showTip(event, 'fs33', 97)" class="t">List</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs38', 98)" onmouseover="showTip(event, 'fs38', 98)" class="f">map</span> <span onmouseout="hideTip(event, 'fs36', 99)" onmouseover="showTip(event, 'fs36', 99)" class="f">f</span> <span onmouseout="hideTip(event, 'fs37', 100)" onmouseover="showTip(event, 'fs37', 100)" class="i">xs</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs33', 101)" onmouseover="showTip(event, 'fs33', 101)" class="t">List</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs39', 102)" onmouseover="showTip(event, 'fs39', 102)" class="f">concat</span>
</code></pre></td>
</tr>
</table>
<p>As you can see. <code>f</code> in our example now can be a <code>'a -&gt; 'b list</code> function. So it now produces a whole new list
for every input of our starting list, but we still get a single list, not a list of list back.</p>
<p>F# also provides an implementation for this function. But it is named <code>List.collect</code> instead of <code>List.bind</code>.</p>
<h2>An operator for <code>bind</code></h2>
<p>In <a href="{% post_url 2016-03-31-applicative-functors %}">Applicative Functors</a> we used <code>&lt;!&gt;</code> for the <code>map</code> function.
And <code>&lt;*&gt;</code> for the <code>apply</code> function. We use <code>&gt;&gt;=</code> as an operator for the <code>bind</code> function. But on top of it.
If we write it as an operator we swap the arguments. We expects our type <code>option</code>, <code>list</code>, <code>async</code> on the
left-side and the function on the right-side.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> (<span class="o">&gt;</span><span class="o">&gt;</span><span class="o">=</span>) <span onmouseout="hideTip(event, 'fs40', 103)" onmouseover="showTip(event, 'fs40', 103)" class="i">m</span> <span onmouseout="hideTip(event, 'fs20', 104)" onmouseover="showTip(event, 'fs20', 104)" class="f">f</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs41', 105)" onmouseover="showTip(event, 'fs41', 105)" class="t">Option</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs42', 106)" onmouseover="showTip(event, 'fs42', 106)" class="f">bind</span> <span onmouseout="hideTip(event, 'fs20', 107)" onmouseover="showTip(event, 'fs20', 107)" class="f">f</span> <span onmouseout="hideTip(event, 'fs40', 108)" onmouseover="showTip(event, 'fs40', 108)" class="i">m</span>
</code></pre></td>
</tr>
</table>
<h2>Continuation-passing Style</h2>
<p>The reason for this change is that we think of <code>bind</code> as some kind of
<a href="https://en.wikipedia.org/wiki/Continuation-passing_style">Continuation-passing Style</a> programming.
To understand the change, we have to go back at the signature. Up until now i often described <code>map</code>
and <code>apply</code> by the idea to just pass in the first argument. So when we have</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp">(<span class="o">&#39;</span><span class="i">a</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs11', 109)" onmouseover="showTip(event, 'fs11', 109)" class="i">option</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">b</span><span class="o">&gt;</span>) <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs11', 110)" onmouseover="showTip(event, 'fs11', 110)" class="i">option</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">a</span><span class="o">&gt;</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs11', 111)" onmouseover="showTip(event, 'fs11', 111)" class="i">option</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">b</span><span class="o">&gt;</span>
</code></pre></td>
</tr>
</table>
<p>we see it as a function that just <em>upgrades</em> the input of a function. But we still have a two argument
function here, and the two argument form is how <code>bind</code> is used most often. If we threat it as
a two-argument function we have something like this:</p>
<p>We have a <code>option&lt;'a&gt;</code> as an input. And we provide a function <code>'a -&gt; option&lt;'b&gt;</code>. As we can see, the input
of <code>f</code> is just <code>'a</code>. So what we get as the input is the <strong>unwrapped</strong> <code>'a</code> that is inside <code>option&lt;'a&gt;</code>.</p>
<p>It can help here if we think with piping <code>|&gt;</code>. The idea of piping is that we can write the next argument
of a function on the left side. So instead of <code>f x</code> we also can write <code>x |&gt; f</code>. When we use <code>bind</code> with
piping we have something like <code>x |&gt; Option.bind f</code>. We also can rearange the <em>type-signature</em> to reflect
this style of writing</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs11', 112)" onmouseover="showTip(event, 'fs11', 112)" class="i">option</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">a</span><span class="o">&gt;</span> <span class="k">-&gt;</span> (<span class="o">&#39;</span><span class="i">a</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs11', 113)" onmouseover="showTip(event, 'fs11', 113)" class="i">option</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">b</span><span class="o">&gt;</span>) <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs11', 114)" onmouseover="showTip(event, 'fs11', 114)" class="i">option</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">b</span><span class="o">&gt;</span>
</code></pre></td>
</tr>
</table>
<p>When we use piping with bind, we get something similar to the above. And probably the order becomes
clearer. We start with a boxed value like <code>option&lt;'a&gt;</code>, then our <code>bind</code> function somehow extract the
<code>'a</code> from our <code>option&lt;'a&gt;</code>, this <code>'a</code> is then passed to the function <code>('a -&gt; option&lt;'b&gt;)</code>. This function
returns an <code>option&lt;'b&gt;</code> what is also what <code>bind</code> will then return!</p>
<p>But it is important to understand that there is no guarantee that our function will be called at all!
Look again at the implementation of <code>bind</code> to understand this. <code>bind</code> checks whether we have <code>None</code> or <code>Some</code>.
In the <code>None</code> case it will just return <code>None</code> only in the <code>Some</code> case it will call <code>f x</code> and execute
our function that we passed to <code>bind</code>!</p>
<p>Not only that, the <em>unwrapping</em> of the <code>option</code> is already handled for us by the <code>bind</code> function. So we
can pass a function <code>f</code> to <code>bind</code> that only will be executed if we have <code>Some value</code>.</p>
<p>Let's create an example to understand this idea in more depth. At first we create a function that
prints some text to screen and expect the user to enter a float. We try to parse the input as
<code>float</code> with our <code>Double.tryParse</code> function that returns an <code>option&lt;float&gt;</code>.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs43', 115)" onmouseover="showTip(event, 'fs43', 115)" class="f">getUserInput</span> <span onmouseout="hideTip(event, 'fs44', 116)" onmouseover="showTip(event, 'fs44', 116)" class="i">msg</span> <span class="o">=</span>
    <span onmouseout="hideTip(event, 'fs45', 117)" onmouseover="showTip(event, 'fs45', 117)" class="f">printfn</span> <span class="s">&quot;</span><span class="pf">%s</span><span class="s">: &quot;</span> <span onmouseout="hideTip(event, 'fs44', 118)" onmouseover="showTip(event, 'fs44', 118)" class="i">msg</span>
    <span onmouseout="hideTip(event, 'fs46', 119)" onmouseover="showTip(event, 'fs46', 119)" class="t">Console</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs47', 120)" onmouseover="showTip(event, 'fs47', 120)" class="f">ReadLine</span>() <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs3', 121)" onmouseover="showTip(event, 'fs3', 121)" class="t">Double</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs26', 122)" onmouseover="showTip(event, 'fs26', 122)" class="f">tryParse</span>
</code></pre></td>
</tr>
</table>
<p>Now we sure could write</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs48', 123)" onmouseover="showTip(event, 'fs48', 123)" class="i">someInput</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs43', 124)" onmouseover="showTip(event, 'fs43', 124)" class="f">getUserInput</span> <span class="s">&quot;Enter a number&quot;</span>
</code></pre></td>
</tr>
</table>
<p>and <code>someInput</code> would contain an <code>option&lt;float&gt;</code>. We now could use that <code>option&lt;float&gt;</code> with other
functions. We just could <code>map</code> or <code>apply</code> all other functions that are not compatible with <code>option</code>.</p>
<p>But instead of doing that, let's pass the resulting <code>option&lt;float&gt;</code> directly to <code>bind</code>. We then
provide a continuation function to <code>bind</code> that only will be executed if we have <code>Some value</code>.
The advantage is that our <code>f</code> function only sees a <code>float</code>, not a <code>option&lt;float&gt;</code>. We now
can do something with that <code>float</code>.</p>
<p>Let's write an example where the user inputs the radius of a circle, and we calculate the
area of that circle.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
<span class="l">8: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs49', 125)" onmouseover="showTip(event, 'fs49', 125)" class="f">retn</span> <span onmouseout="hideTip(event, 'fs18', 126)" onmouseover="showTip(event, 'fs18', 126)" class="i">x</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs9', 127)" onmouseover="showTip(event, 'fs9', 127)" class="p">Some</span> <span onmouseout="hideTip(event, 'fs18', 128)" onmouseover="showTip(event, 'fs18', 128)" class="i">x</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs50', 129)" onmouseover="showTip(event, 'fs50', 129)" class="f">circleArea</span> <span onmouseout="hideTip(event, 'fs51', 130)" onmouseover="showTip(event, 'fs51', 130)" class="i">r</span> <span class="o">=</span> (<span onmouseout="hideTip(event, 'fs51', 131)" onmouseover="showTip(event, 'fs51', 131)" class="i">r</span> <span class="o">**</span> <span class="n">2.0</span>) <span class="o">*</span> <span onmouseout="hideTip(event, 'fs52', 132)" onmouseover="showTip(event, 'fs52', 132)" class="t">Math</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs53', 133)" onmouseover="showTip(event, 'fs53', 133)" class="i">PI</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs54', 134)" onmouseover="showTip(event, 'fs54', 134)" class="i">area</span> <span class="o">=</span>
    <span onmouseout="hideTip(event, 'fs43', 135)" onmouseover="showTip(event, 'fs43', 135)" class="f">getUserInput</span> <span class="s">&quot;Enter radius&quot;</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs41', 136)" onmouseover="showTip(event, 'fs41', 136)" class="t">Option</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs42', 137)" onmouseover="showTip(event, 'fs42', 137)" class="f">bind</span> (<span class="k">fun</span> <span onmouseout="hideTip(event, 'fs55', 138)" onmouseover="showTip(event, 'fs55', 138)" class="i">userInput</span> <span class="k">-&gt;</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs56', 139)" onmouseover="showTip(event, 'fs56', 139)" class="i">area</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs50', 140)" onmouseover="showTip(event, 'fs50', 140)" class="f">circleArea</span> <span onmouseout="hideTip(event, 'fs55', 141)" onmouseover="showTip(event, 'fs55', 141)" class="i">userInput</span>
        <span onmouseout="hideTip(event, 'fs49', 142)" onmouseover="showTip(event, 'fs49', 142)" class="f">retn</span> <span onmouseout="hideTip(event, 'fs56', 143)" onmouseover="showTip(event, 'fs56', 143)" class="i">area</span>
    )
</code></pre></td>
</tr>
</table>
<p>Let's go through the example step-by-step.</p>
<ol>
<li>
At first we just create a function <code>circleArea</code> that calculates the area from a given radius.
For such a function we just expect <code>float</code> as input. We usually don't expect <code>option&lt;float&gt;</code>
or <code>list&lt;float&gt;</code> as the input.
</li>
<li>
Then we call <code>getUserInput "Enter radius"</code>. The user will see "Enter radius: " and he must enter
something. The input will be parsed as a <code>float</code>. We will either get <code>Some x</code> back if
the user input was a <code>float</code> or <code>None</code> if the input was not valid.
</li>
<li>
This option is then directly passed to <code>Option.bind</code> as the second argument. We use the Pipe <code>|&gt;</code>
here to bring the <code>option</code> to the left-side.
</li>
<li>
The right-side is now a continuation function. If the <code>option</code> passed to <code>bind</code> contains <code>Some x</code>,
that means a valid <code>float</code>, our continuation function is called and <code>bind</code> returns the result
of our continuation function. If the input to <code>bind</code> was <code>None</code>, <code>bind</code> will immediately return <code>None</code>
without executing the continuation function.
</li>
<li>
Look at the type of <code>userInput</code>. It is a <code>float</code> not an <code>option&lt;float&gt;</code>. We have a continuation
function that only will be execute if we have a valid <code>float</code>. And we can directly work
with a <code>float</code>.
</li>
<li>
In our Continuation function we use the <code>float</code> to calculate the area of a circle. As
we only have <code>float</code> not an <code>option&lt;float&gt;</code> we don't have to <code>map</code> <code>circleArea</code>.
</li>
<li>
As you now can see <code>let area</code> inside our continuation function is now a normal <code>float</code>. But
now we want to return <code>area</code> as the result of our calculation. But <code>bind</code> must return
an <code>option</code> value. So how do we do that? We use our <code>retn</code> (return) function to convert
a normal <code>float</code> into an <code>option&lt;float&gt;</code>
</li>
<li>
Our outer <code>area</code> is now a <code>option&lt;float&gt;</code> that either is <code>Some</code> and contains the calculated area
for a circle. Or it is <code>None</code>, because the user input could not be parsed.
</li>
</ol>
<p>Currently we don't print the result. So let's print <code>area</code>. As <code>area</code> (outside of the
continuation function) is now a <code>option&lt;float&gt;</code> we have to Pattern Match it to see if our computation
was successful or not.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">match</span> <span onmouseout="hideTip(event, 'fs54', 144)" onmouseover="showTip(event, 'fs54', 144)" class="i">area</span> <span class="k">with</span>
| <span onmouseout="hideTip(event, 'fs7', 145)" onmouseover="showTip(event, 'fs7', 145)" class="p">None</span>      <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs45', 146)" onmouseover="showTip(event, 'fs45', 146)" class="f">printfn</span> <span class="s">&quot;User Input was not a valid number&quot;</span>
| <span onmouseout="hideTip(event, 'fs9', 147)" onmouseover="showTip(event, 'fs9', 147)" class="p">Some</span> <span onmouseout="hideTip(event, 'fs56', 148)" onmouseover="showTip(event, 'fs56', 148)" class="i">area</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs45', 149)" onmouseover="showTip(event, 'fs45', 149)" class="f">printfn</span> <span class="s">&quot;The area of a circle is </span><span class="pf">%f</span><span class="s">&quot;</span> <span onmouseout="hideTip(event, 'fs56', 150)" onmouseover="showTip(event, 'fs56', 150)" class="i">area</span>
</code></pre></td>
</tr>
</table>
<p>If the user input was <code>10</code> for example, we will see <code>The area of a circle is 314.159265</code>, but if we provide
an invalid input, we just see <code>User Input was not a valid number</code>. In our example we first had a<br />
<code>option</code> value and passed it to <code>Option.bind</code> with <code>|&gt;</code>. This happens often, that is why we created
<code>&gt;&gt;=</code> previously.</p>
<p>Let's extend that example. We now ask the user for three inputs. And we will calculate the volume
of a cube.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs57', 151)" onmouseover="showTip(event, 'fs57', 151)" class="i">cubeVolume</span> <span class="o">=</span>
    <span onmouseout="hideTip(event, 'fs43', 152)" onmouseover="showTip(event, 'fs43', 152)" class="f">getUserInput</span> <span class="s">&quot;Length X&quot;</span> <span class="o">&gt;</span><span class="o">&gt;</span><span class="o">=</span> (<span class="k">fun</span> <span onmouseout="hideTip(event, 'fs8', 153)" onmouseover="showTip(event, 'fs8', 153)" class="i">x</span> <span class="k">-&gt;</span>
    <span onmouseout="hideTip(event, 'fs43', 154)" onmouseover="showTip(event, 'fs43', 154)" class="f">getUserInput</span> <span class="s">&quot;Length Y&quot;</span> <span class="o">&gt;</span><span class="o">&gt;</span><span class="o">=</span> (<span class="k">fun</span> <span onmouseout="hideTip(event, 'fs58', 155)" onmouseover="showTip(event, 'fs58', 155)" class="i">y</span> <span class="k">-&gt;</span>
    <span onmouseout="hideTip(event, 'fs43', 156)" onmouseover="showTip(event, 'fs43', 156)" class="f">getUserInput</span> <span class="s">&quot;Length Z&quot;</span> <span class="o">&gt;</span><span class="o">&gt;</span><span class="o">=</span> (<span class="k">fun</span> <span onmouseout="hideTip(event, 'fs59', 157)" onmouseover="showTip(event, 'fs59', 157)" class="i">z</span> <span class="k">-&gt;</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs60', 158)" onmouseover="showTip(event, 'fs60', 158)" class="i">volume</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs8', 159)" onmouseover="showTip(event, 'fs8', 159)" class="i">x</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'fs58', 160)" onmouseover="showTip(event, 'fs58', 160)" class="i">y</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'fs59', 161)" onmouseover="showTip(event, 'fs59', 161)" class="i">z</span>
        <span onmouseout="hideTip(event, 'fs49', 162)" onmouseover="showTip(event, 'fs49', 162)" class="f">retn</span> <span onmouseout="hideTip(event, 'fs60', 163)" onmouseover="showTip(event, 'fs60', 163)" class="i">volume</span>
    )))

<span class="k">match</span> <span onmouseout="hideTip(event, 'fs57', 164)" onmouseover="showTip(event, 'fs57', 164)" class="i">cubeVolume</span> <span class="k">with</span>
| <span onmouseout="hideTip(event, 'fs7', 165)" onmouseover="showTip(event, 'fs7', 165)" class="p">None</span>        <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs45', 166)" onmouseover="showTip(event, 'fs45', 166)" class="f">printfn</span> <span class="s">&quot;Not all inputs were valid&quot;</span>
| <span onmouseout="hideTip(event, 'fs9', 167)" onmouseover="showTip(event, 'fs9', 167)" class="p">Some</span> <span onmouseout="hideTip(event, 'fs60', 168)" onmouseover="showTip(event, 'fs60', 168)" class="i">volume</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs45', 169)" onmouseover="showTip(event, 'fs45', 169)" class="f">printfn</span> <span class="s">&quot;Volume of cube is: </span><span class="pf">%f</span><span class="s">&quot;</span> <span onmouseout="hideTip(event, 'fs60', 170)" onmouseover="showTip(event, 'fs60', 170)" class="i">volume</span>
</code></pre></td>
</tr>
</table>
<p>As we can see now. We ask the user three times to input a number X, Y and Z. If all inputs were valid. We
just calculate the volume with <code>let volume = x * y * z</code>. The important aspect is that all of our values
are always <code>float</code> never <code>option&lt;float&gt;</code>, because the <code>bind</code> operation <code>&gt;&gt;=</code> already did the
unwrapping for us.</p>
<p>And probably it now becomes clear why we named our <em>constructor</em> <code>return</code> (retn). Inside of our
continuation functions we never have lifted values. But at the end of our continuation functions we
always must return a lifted value. So <em>lifting</em> and <em>returning</em> is always the last statement we do.</p>
<p>Let's inspect the syntax a little bit deeper. Look at the syntax of a normal <code>let</code>
definition in F#. Usually a <code>let</code> definition contains a name, a equal "=" and a expression that
will be executed. Actually just look at the following two lines and just compare them.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">x</span> <span class="o">=</span> <span class="i">getUserInput</span> <span class="s">&quot;Length X&quot;</span>
<span class="i">getUserInput</span> <span class="s">&quot;Length X&quot;</span> <span class="o">&gt;</span><span class="o">&gt;</span><span class="o">=</span> (<span class="k">fun</span> <span class="i">x</span> <span class="k">-&gt;</span>
</code></pre></td>
</tr>
</table>
<p>Do you spot the similarities?</p>
<ol>
<li>Both definition have an expression <code>getUserInput "Length X"</code> this expression will be executed.</li>
<li>In the first example: We only have <code>=</code> for assignment, and we assign the result to <code>let x</code>.</li>
<li>In the second example: We have <code>&gt;&gt;= (fun x</code> as we assign the result of the expression to <code>x</code>.</li>
</ol>
<p>So what is the difference between both?</p>
<p>The first difference is that the statements are just flipped. With <code>let</code> we have something like</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">variable</span> <span class="o">=</span> <span class="i">expression</span>
</code></pre></td>
</tr>
</table>
<p>But with our <code>bind</code> operation we just have</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">expression</span> <span class="o">&gt;</span><span class="o">&gt;</span><span class="o">=</span> (<span class="k">fun</span> <span class="i">variable</span> <span class="k">-&gt;</span>
</code></pre></td>
</tr>
</table>
<p>But the more important difference is the result (our variable). In a normal <code>let</code> definition we
will get <code>option&lt;float&gt;</code>. But with <code>bind</code>, we just get <code>float</code>. <code>bind</code> decides whether our
continuation function should be called or not.</p>
<h2>Computation Expressions</h2>
<p>The idea of this kind of continuation-passing style is actually really powerful. So powerful that F#
provides a language construct to let it look like normal code. At first, we just create a class
that contains a <code>Bind</code> and <code>Return</code> method that we want to use.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, 'fs61', 171)" onmouseover="showTip(event, 'fs61', 171)" class="t">MaybeBuilder</span>() <span class="o">=</span>
    <span class="k">member</span> <span onmouseout="hideTip(event, 'fs62', 172)" onmouseover="showTip(event, 'fs62', 172)" class="i">o</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs63', 173)" onmouseover="showTip(event, 'fs63', 173)" class="f">Bind</span>(<span onmouseout="hideTip(event, 'fs64', 174)" onmouseover="showTip(event, 'fs64', 174)" class="i">m</span>,<span onmouseout="hideTip(event, 'fs65', 175)" onmouseover="showTip(event, 'fs65', 175)" class="f">f</span>) <span class="o">=</span> <span onmouseout="hideTip(event, 'fs41', 176)" onmouseover="showTip(event, 'fs41', 176)" class="t">Option</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs42', 177)" onmouseover="showTip(event, 'fs42', 177)" class="f">bind</span> <span onmouseout="hideTip(event, 'fs65', 178)" onmouseover="showTip(event, 'fs65', 178)" class="f">f</span> <span onmouseout="hideTip(event, 'fs64', 179)" onmouseover="showTip(event, 'fs64', 179)" class="i">m</span>
    <span class="k">member</span> <span onmouseout="hideTip(event, 'fs62', 180)" onmouseover="showTip(event, 'fs62', 180)" class="i">o</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs66', 181)" onmouseover="showTip(event, 'fs66', 181)" class="f">Return</span>(<span onmouseout="hideTip(event, 'fs18', 182)" onmouseover="showTip(event, 'fs18', 182)" class="i">x</span>) <span class="o">=</span> <span onmouseout="hideTip(event, 'fs9', 183)" onmouseover="showTip(event, 'fs9', 183)" class="p">Some</span> <span onmouseout="hideTip(event, 'fs18', 184)" onmouseover="showTip(event, 'fs18', 184)" class="i">x</span>

<span class="k">let</span> <span onmouseout="hideTip(event, 'fs67', 185)" onmouseover="showTip(event, 'fs67', 185)" class="i">maybe</span> <span class="o">=</span> <span class="k">new</span> <span onmouseout="hideTip(event, 'fs61', 186)" onmouseover="showTip(event, 'fs61', 186)" class="t">MaybeBuilder</span>()
</code></pre></td>
</tr>
</table>
<p>As you can see. The <code>Bind</code> and <code>Return</code> methods are not special. They are just the functions you already
know! After you created a class you must create an object of this class. That is our <code>maybe</code>. Now you
can use the following special syntax.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs68', 187)" onmouseover="showTip(event, 'fs68', 187)" class="i">cubeVolume2</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs67', 188)" onmouseover="showTip(event, 'fs67', 188)" class="i">maybe</span> {
    <span class="k">let!</span> <span onmouseout="hideTip(event, 'fs8', 189)" onmouseover="showTip(event, 'fs8', 189)" class="i">x</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs43', 190)" onmouseover="showTip(event, 'fs43', 190)" class="f">getUserInput</span> <span class="s">&quot;Length X&quot;</span>
    <span class="k">let!</span> <span onmouseout="hideTip(event, 'fs58', 191)" onmouseover="showTip(event, 'fs58', 191)" class="i">y</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs43', 192)" onmouseover="showTip(event, 'fs43', 192)" class="f">getUserInput</span> <span class="s">&quot;Length Y&quot;</span>
    <span class="k">let!</span> <span onmouseout="hideTip(event, 'fs59', 193)" onmouseover="showTip(event, 'fs59', 193)" class="i">z</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs43', 194)" onmouseover="showTip(event, 'fs43', 194)" class="f">getUserInput</span> <span class="s">&quot;Length Z&quot;</span>
    <span class="k">let</span>  <span onmouseout="hideTip(event, 'fs60', 195)" onmouseover="showTip(event, 'fs60', 195)" class="i">volume</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs8', 196)" onmouseover="showTip(event, 'fs8', 196)" class="i">x</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'fs58', 197)" onmouseover="showTip(event, 'fs58', 197)" class="i">y</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'fs59', 198)" onmouseover="showTip(event, 'fs59', 198)" class="i">z</span>
    <span class="k">return</span> <span onmouseout="hideTip(event, 'fs60', 199)" onmouseover="showTip(event, 'fs60', 199)" class="i">volume</span>
}

<span class="k">match</span> <span onmouseout="hideTip(event, 'fs68', 200)" onmouseover="showTip(event, 'fs68', 200)" class="i">cubeVolume2</span> <span class="k">with</span>
| <span onmouseout="hideTip(event, 'fs7', 201)" onmouseover="showTip(event, 'fs7', 201)" class="p">None</span>     <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs45', 202)" onmouseover="showTip(event, 'fs45', 202)" class="f">printfn</span> <span class="s">&quot;User entered some invalid number&quot;</span>
| <span onmouseout="hideTip(event, 'fs9', 203)" onmouseover="showTip(event, 'fs9', 203)" class="p">Some</span> <span onmouseout="hideTip(event, 'fs69', 204)" onmouseover="showTip(event, 'fs69', 204)" class="i">vol</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs45', 205)" onmouseover="showTip(event, 'fs45', 205)" class="f">printfn</span> <span class="s">&quot;Cube volume is </span><span class="pf">%f</span><span class="s">&quot;</span> <span onmouseout="hideTip(event, 'fs69', 206)" onmouseover="showTip(event, 'fs69', 206)" class="i">vol</span>
</code></pre></td>
</tr>
</table>
<p>So, what happens exactly here? Whenever you use <code>let!</code> <code>Bind</code> is just called. That means,
if you have <code>option&lt;float&gt;</code> on the right side. But you use <code>let! x</code>. Then you just get a <code>float</code>.
Every code after <code>let!</code> is automatically converted into a continuation function that is passed to
<code>Bind</code>. The <code>return</code> statement (that is only available inside a computation expression) turns
a normal value into a lifted value. In this example it wraps it inside a <code>option</code>.</p>
<p>You now can write code as <code>option</code> doesn't exists at all. Whenever you have a
function that returns an <code>option</code>, you just must use <code>let!</code> instead of <code>let</code>. The <code>let!</code> call uses
<code>Bind</code> under the hood. You never need to upgrade functions with <code>map</code> or <code>apply</code> as you don't
work with lifted values. You can use all your functions directly.</p>
<p>But it doesn't mean that we just erased <code>option</code>. <code>option</code> is still present, but the handling
of it is done by the <code>bind</code> function. Whenever we have an expression on the right side that for example
returns a <code>None</code> then the computation stops at this point. Why? Because our <code>bind</code> function only calls
the passed in <code>f</code> function (the continuation) in the <code>Some</code> case.</p>
<p>And it overall also means that the result of a <code>maybe { ... }</code> is always an <code>option</code>! Because it
is an <code>option</code> you easily can use functions defined with a <code>maybe { ... }</code> construct in other
<code>maybe { ... }</code> constructs.</p>
<p>On top of it you still get the safety that <code>option</code> provides you, that means at some point you must
check the value. But it is up to you if you just use a generic check that you implemented in <code>bind</code>, or
write your own handling.</p>
<p>What you see here is a basic implementation of the <strong>Maybe Monad</strong>. And it is the implementation of
the second solution I showed in the <a href="{% post_url 2016-03-20-null-is-evil %}">null is Evil</a> post.</p>
<h2>Defining <code>map</code> and <code>apply</code> through <code>bind</code></h2>
<p>The combination of <code>return</code> and <code>bind</code> is really powerful. In
<a href="{% post_url 2016-03-31-applicative-functors %}">Applicative Functors</a> we already saw that we can
implement <code>map</code> through <code>return</code> and <code>apply</code>. But with <code>return</code> and <code>bind</code> we can easily implement
<code>map</code> and <code>apply</code>.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
<span class="l">14: </span>
<span class="l">15: </span>
<span class="l">16: </span>
<span class="l">17: </span>
<span class="l">18: </span>
<span class="l">19: </span>
<span class="l">20: </span>
<span class="l">21: </span>
<span class="l">22: </span>
<span class="l">23: </span>
<span class="l">24: </span>
<span class="l">25: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// map with bind operator</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs70', 207)" onmouseover="showTip(event, 'fs70', 207)" class="f">map</span> <span onmouseout="hideTip(event, 'fs16', 208)" onmouseover="showTip(event, 'fs16', 208)" class="f">f</span> <span onmouseout="hideTip(event, 'fs17', 209)" onmouseover="showTip(event, 'fs17', 209)" class="i">opt</span> <span class="o">=</span> 
    <span onmouseout="hideTip(event, 'fs17', 210)" onmouseover="showTip(event, 'fs17', 210)" class="i">opt</span> <span class="o">&gt;</span><span class="o">&gt;</span><span class="o">=</span> (<span class="k">fun</span> <span onmouseout="hideTip(event, 'fs18', 211)" onmouseover="showTip(event, 'fs18', 211)" class="i">x</span> <span class="k">-&gt;</span> <span class="c">// unbox option</span>
        <span onmouseout="hideTip(event, 'fs49', 212)" onmouseover="showTip(event, 'fs49', 212)" class="f">retn</span> (<span onmouseout="hideTip(event, 'fs16', 213)" onmouseover="showTip(event, 'fs16', 213)" class="f">f</span> <span onmouseout="hideTip(event, 'fs18', 214)" onmouseover="showTip(event, 'fs18', 214)" class="i">x</span>)    <span class="c">// execute (f x) and box result</span>
    )

<span class="c">// map defined with Computation Expression</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs70', 215)" onmouseover="showTip(event, 'fs70', 215)" class="f">map</span> <span onmouseout="hideTip(event, 'fs16', 216)" onmouseover="showTip(event, 'fs16', 216)" class="f">f</span> <span onmouseout="hideTip(event, 'fs17', 217)" onmouseover="showTip(event, 'fs17', 217)" class="i">opt</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs67', 218)" onmouseover="showTip(event, 'fs67', 218)" class="i">maybe</span> {
    <span class="k">let!</span> <span onmouseout="hideTip(event, 'fs18', 219)" onmouseover="showTip(event, 'fs18', 219)" class="i">x</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs17', 220)" onmouseover="showTip(event, 'fs17', 220)" class="i">opt</span>  <span class="c">// unbox option</span>
    <span class="k">return</span> <span onmouseout="hideTip(event, 'fs16', 221)" onmouseover="showTip(event, 'fs16', 221)" class="f">f</span> <span onmouseout="hideTip(event, 'fs18', 222)" onmouseover="showTip(event, 'fs18', 222)" class="i">x</span>    <span class="c">// execute (f x) and box result</span>
}

<span class="c">// Apply with bind operator</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs71', 223)" onmouseover="showTip(event, 'fs71', 223)" class="f">apply</span> <span onmouseout="hideTip(event, 'fs72', 224)" onmouseover="showTip(event, 'fs72', 224)" class="i">fo</span> <span onmouseout="hideTip(event, 'fs73', 225)" onmouseover="showTip(event, 'fs73', 225)" class="i">xo</span> <span class="o">=</span>
    <span onmouseout="hideTip(event, 'fs72', 226)" onmouseover="showTip(event, 'fs72', 226)" class="i">fo</span> <span class="o">&gt;</span><span class="o">&gt;</span><span class="o">=</span> (<span class="k">fun</span> <span onmouseout="hideTip(event, 'fs16', 227)" onmouseover="showTip(event, 'fs16', 227)" class="f">f</span> <span class="k">-&gt;</span>  <span class="c">// unbox function</span>
    <span onmouseout="hideTip(event, 'fs73', 228)" onmouseover="showTip(event, 'fs73', 228)" class="i">xo</span> <span class="o">&gt;</span><span class="o">&gt;</span><span class="o">=</span> (<span class="k">fun</span> <span onmouseout="hideTip(event, 'fs18', 229)" onmouseover="showTip(event, 'fs18', 229)" class="i">x</span> <span class="k">-&gt;</span>  <span class="c">// unbox value</span>
        <span onmouseout="hideTip(event, 'fs49', 230)" onmouseover="showTip(event, 'fs49', 230)" class="f">retn</span> (<span onmouseout="hideTip(event, 'fs16', 231)" onmouseover="showTip(event, 'fs16', 231)" class="f">f</span> <span onmouseout="hideTip(event, 'fs18', 232)" onmouseover="showTip(event, 'fs18', 232)" class="i">x</span>)    <span class="c">// execute (f x) and box result</span>
    ))

<span class="c">// Apply with Computation expression</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs71', 233)" onmouseover="showTip(event, 'fs71', 233)" class="f">apply</span> <span onmouseout="hideTip(event, 'fs72', 234)" onmouseover="showTip(event, 'fs72', 234)" class="i">fo</span> <span onmouseout="hideTip(event, 'fs73', 235)" onmouseover="showTip(event, 'fs73', 235)" class="i">xo</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs67', 236)" onmouseover="showTip(event, 'fs67', 236)" class="i">maybe</span> {
    <span class="k">let!</span> <span onmouseout="hideTip(event, 'fs16', 237)" onmouseover="showTip(event, 'fs16', 237)" class="f">f</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs72', 238)" onmouseover="showTip(event, 'fs72', 238)" class="i">fo</span>  <span class="c">// unbox function</span>
    <span class="k">let!</span> <span onmouseout="hideTip(event, 'fs18', 239)" onmouseover="showTip(event, 'fs18', 239)" class="i">x</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs73', 240)" onmouseover="showTip(event, 'fs73', 240)" class="i">xo</span>  <span class="c">// unbox value</span>
    <span class="k">return</span> <span onmouseout="hideTip(event, 'fs16', 241)" onmouseover="showTip(event, 'fs16', 241)" class="f">f</span> <span onmouseout="hideTip(event, 'fs18', 242)" onmouseover="showTip(event, 'fs18', 242)" class="i">x</span>   <span class="c">// execute (f x) and box result</span>
}
</code></pre></td>
</tr>
</table>
<p>Because of this we always have an <em>Applicative Functor</em> when we have a <em>Monad</em>.</p>
<h2>Kleisli Composition</h2>
<p>Function composition is the idea to create a new function out of two smaller functions. It
usually works as long we have two function with a matching output and input type.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp">(<span class="o">&#39;</span><span class="i">a</span> <span class="k">-&gt;</span> <span class="o">&#39;</span><span class="i">b</span>) <span class="o">&gt;</span><span class="o">&gt;</span> (<span class="o">&#39;</span><span class="i">b</span> <span class="k">-&gt;</span> <span class="o">&#39;</span><span class="i">c</span>)
</code></pre></td>
</tr>
</table>
<p>Because <code>'b</code> is the output of anothers function input, we can directly create a new composed
function that goes from <code>'a</code> to <code>'c</code> <code>'a -&gt; 'c</code>. But this doesn't work for <em>Monadic functions</em>
as they don't have matching input/output.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="o">&#39;</span><span class="i">a</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs11', 243)" onmouseover="showTip(event, 'fs11', 243)" class="i">option</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">b</span><span class="o">&gt;</span>
<span class="o">&#39;</span><span class="i">b</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs11', 244)" onmouseover="showTip(event, 'fs11', 244)" class="i">option</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">c</span><span class="o">&gt;</span>
</code></pre></td>
</tr>
</table>
<p>These functions cannot be composed because <code>option&lt;'b&gt;</code> is not the same as <code>'b</code>. But with our
bind operator <code>&gt;&gt;=</code> we can easily pass boxed values into function that don't expect them. Because
of that we also can create a compose function that directly compose two <em>Monadic functions</em>.
We use the operator <code>&gt;=&gt;</code> for this kind of composition. This kind of composition is also named
<em>Kleisli composition</em>.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> (<span class="o">&gt;</span><span class="o">&gt;</span>)  <span onmouseout="hideTip(event, 'fs16', 245)" onmouseover="showTip(event, 'fs16', 245)" class="f">f</span> <span onmouseout="hideTip(event, 'fs74', 246)" onmouseover="showTip(event, 'fs74', 246)" class="f">g</span> <span onmouseout="hideTip(event, 'fs18', 247)" onmouseover="showTip(event, 'fs18', 247)" class="i">x</span> <span class="o">=</span> (<span onmouseout="hideTip(event, 'fs16', 248)" onmouseover="showTip(event, 'fs16', 248)" class="f">f</span> <span onmouseout="hideTip(event, 'fs18', 249)" onmouseover="showTip(event, 'fs18', 249)" class="i">x</span>) <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs74', 250)" onmouseover="showTip(event, 'fs74', 250)" class="f">g</span>   <span class="c">// This is how normal composition is defined</span>
<span class="k">let</span> (<span class="o">&gt;</span><span class="o">=&gt;</span>) <span onmouseout="hideTip(event, 'fs20', 251)" onmouseover="showTip(event, 'fs20', 251)" class="f">f</span> <span onmouseout="hideTip(event, 'fs75', 252)" onmouseover="showTip(event, 'fs75', 252)" class="f">g</span> <span onmouseout="hideTip(event, 'fs18', 253)" onmouseover="showTip(event, 'fs18', 253)" class="i">x</span> <span class="o">=</span> (<span onmouseout="hideTip(event, 'fs20', 254)" onmouseover="showTip(event, 'fs20', 254)" class="f">f</span> <span onmouseout="hideTip(event, 'fs18', 255)" onmouseover="showTip(event, 'fs18', 255)" class="i">x</span>) <span class="o">&gt;</span><span class="o">&gt;</span><span class="o">=</span> <span onmouseout="hideTip(event, 'fs75', 256)" onmouseover="showTip(event, 'fs75', 256)" class="f">g</span>  <span class="c">// This is Kleisli composition</span>
</code></pre></td>
</tr>
</table>
<p>Now we can compose two <em>Monadic</em> functions directly.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp">(<span class="o">&#39;</span><span class="i">a</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs11', 257)" onmouseover="showTip(event, 'fs11', 257)" class="i">option</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">b</span><span class="o">&gt;</span>) <span class="o">&gt;</span><span class="o">=&gt;</span> (<span class="o">&#39;</span><span class="i">b</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs11', 258)" onmouseover="showTip(event, 'fs11', 258)" class="i">option</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">c</span><span class="o">&gt;</span>)
</code></pre></td>
</tr>
</table>
<p>the result is a new <em>Monadic function</em>.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="o">&#39;</span><span class="i">a</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs11', 259)" onmouseover="showTip(event, 'fs11', 259)" class="i">option</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">c</span><span class="o">&gt;</span>
</code></pre></td>
</tr>
</table>
<h2>Laws</h2>
<p>We already saw Laws for <em>Functors</em> and <em>Applicative Functors</em>. The combination of <code>return</code>
and <code>bind</code> (a Monad) also must satisfy three laws. In the following description I use</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs76', 260)" onmouseover="showTip(event, 'fs76', 260)" class="f">f</span>   <span class="o">=</span> <span onmouseout="hideTip(event, 'fs3', 261)" onmouseover="showTip(event, 'fs3', 261)" class="t">Double</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs26', 262)" onmouseover="showTip(event, 'fs26', 262)" class="f">tryParse</span> <span class="c">// string -&gt; option&lt;float&gt;</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs77', 263)" onmouseover="showTip(event, 'fs77', 263)" class="f">g</span> <span onmouseout="hideTip(event, 'fs8', 264)" onmouseover="showTip(event, 'fs8', 264)" class="i">x</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs49', 265)" onmouseover="showTip(event, 'fs49', 265)" class="f">retn</span> (<span onmouseout="hideTip(event, 'fs8', 266)" onmouseover="showTip(event, 'fs8', 266)" class="i">x</span> <span class="o">*</span> <span class="n">2.0</span>)  <span class="c">// float  -&gt; option&lt;float&gt;</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs78', 267)" onmouseover="showTip(event, 'fs78', 267)" class="i">x</span>   <span class="o">=</span> <span class="s">&quot;10&quot;</span>            <span class="c">// string         -- unboxed value</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs79', 268)" onmouseover="showTip(event, 'fs79', 268)" class="i">m</span>   <span class="o">=</span> <span onmouseout="hideTip(event, 'fs49', 269)" onmouseover="showTip(event, 'fs49', 269)" class="f">retn</span> <span class="s">&quot;10&quot;</span>       <span class="c">// option&lt;string&gt; -- a boxed value</span>
</code></pre></td>
</tr>
</table>
<p>But sure, all laws have to work with any function or value combination. But seeing some actual
values makes it easier to understand the laws.</p>
<h3>1. Law: Left identity</h3>
<p>When we <code>return</code> (box) a value and then use <code>bind</code> (that unbox the value) and pass it to a function.
It is the same as directly passing the value to a function.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs49', 270)" onmouseover="showTip(event, 'fs49', 270)" class="f">retn</span> <span onmouseout="hideTip(event, 'fs78', 271)" onmouseover="showTip(event, 'fs78', 271)" class="i">x</span> <span class="o">&gt;</span><span class="o">&gt;</span><span class="o">=</span> <span onmouseout="hideTip(event, 'fs76', 272)" onmouseover="showTip(event, 'fs76', 272)" class="f">f</span>  <span class="o">=</span>  <span onmouseout="hideTip(event, 'fs76', 273)" onmouseover="showTip(event, 'fs76', 273)" class="f">f</span> <span onmouseout="hideTip(event, 'fs78', 274)" onmouseover="showTip(event, 'fs78', 274)" class="i">x</span>  <span class="c">// (Some 10.0) = (Some 10.0) -&gt; true</span>
</code></pre></td>
</tr>
</table>
<h3>2. Law: Right identity</h3>
<p>Binding a boxed value and returning it, is the same as the boxed value</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs79', 275)" onmouseover="showTip(event, 'fs79', 275)" class="i">m</span> <span class="o">&gt;</span><span class="o">&gt;</span><span class="o">=</span> <span onmouseout="hideTip(event, 'fs49', 276)" onmouseover="showTip(event, 'fs49', 276)" class="f">retn</span>  <span class="o">=</span>  <span onmouseout="hideTip(event, 'fs79', 277)" onmouseover="showTip(event, 'fs79', 277)" class="i">m</span>
</code></pre></td>
</tr>
</table>
<h3>3. Law: Associative</h3>
<p>Order of composing don't play a role. We can pass a value to <code>f</code> and the result to <code>g</code> and
it has to be the same as if we compose <code>f</code> and <code>g</code> first, and pass our value to the composed
function.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs80', 278)" onmouseover="showTip(event, 'fs80', 278)" class="i">ax</span> <span class="o">=</span> (<span onmouseout="hideTip(event, 'fs79', 279)" onmouseover="showTip(event, 'fs79', 279)" class="i">m</span> <span class="o">&gt;</span><span class="o">&gt;</span><span class="o">=</span> <span onmouseout="hideTip(event, 'fs76', 280)" onmouseover="showTip(event, 'fs76', 280)" class="f">f</span>) <span class="o">&gt;</span><span class="o">&gt;</span><span class="o">=</span> <span onmouseout="hideTip(event, 'fs77', 281)" onmouseover="showTip(event, 'fs77', 281)" class="f">g</span>   <span class="c">// Calling f with m then pass result to g</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs81', 282)" onmouseover="showTip(event, 'fs81', 282)" class="i">ay</span> <span class="o">=</span>  <span onmouseout="hideTip(event, 'fs79', 283)" onmouseover="showTip(event, 'fs79', 283)" class="i">m</span> <span class="o">&gt;</span><span class="o">&gt;</span><span class="o">=</span> (<span onmouseout="hideTip(event, 'fs76', 284)" onmouseover="showTip(event, 'fs76', 284)" class="f">f</span> <span class="o">&gt;</span><span class="o">=&gt;</span> <span onmouseout="hideTip(event, 'fs77', 285)" onmouseover="showTip(event, 'fs77', 285)" class="f">g</span>)  <span class="c">// Compose f and g first, then pass it m</span>

<span onmouseout="hideTip(event, 'fs80', 286)" onmouseover="showTip(event, 'fs80', 286)" class="i">ax</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs81', 287)" onmouseover="showTip(event, 'fs81', 287)" class="i">ay</span> <span class="c">// Must be the same</span>
</code></pre></td>
</tr>
</table>
<h2>Summary</h2>
<p>With <code>map</code>, <code>retn</code>, <code>apply</code> and <code>bind</code> we have four general functions that simplifies working
with <em>boxed</em> types like <code>option</code>, <code>list</code>, <code>Async</code> and so on. Whenever you create a new type you
should consider implementing those functions too. Here is a quick overview of those
functions and when to use them.</p>
<h3><code>map</code></h3>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp">(<span class="o">&#39;</span><span class="i">a</span> <span class="k">-&gt;</span> <span class="o">&#39;</span><span class="i">b</span>) <span class="k">-&gt;</span> <span class="i">M</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">a</span><span class="o">&gt;</span> <span class="k">-&gt;</span> <span class="i">M</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">b</span><span class="o">&gt;</span>
</code></pre></td>
</tr>
</table>
<p>When we interpret it as a "one-argument" function we can add our boxed type <code>M</code> to the input and
output of a function.</p>
<p>Interpreted as a "two-argument" function we can use a boxed value <code>M&lt;'a&gt;</code> directly with a function
that can work with the wrapped type <code>'a</code>.</p>
<h3><code>apply</code></h3>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">M</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">a</span> <span class="k">-&gt;</span> <span class="o">&#39;</span><span class="i">b</span><span class="o">&gt;</span> <span class="k">-&gt;</span> <span class="i">M</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">a</span><span class="o">&gt;</span> <span class="k">-&gt;</span> <span class="i">M</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">b</span><span class="o">&gt;</span>
</code></pre></td>
</tr>
</table>
<p>With apply we can work with boxed functions. We get those as a result if we try to <code>map</code> a function
that has more than one argument. Or we just lift a function with <code>return</code>. We can view <code>apply</code> as
<em>Partial Application</em> for <em>boxed</em> function. With every call we can provide the next value to a
function that also is a boxed value. In this way we can turn every argument of a function
to a boxed value. A function like <code>int -&gt; string -&gt; float -&gt; int</code> can thus be turned into</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">M</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs82', 288)" onmouseover="showTip(event, 'fs82', 288)" class="i">int</span><span class="o">&gt;</span> <span class="k">-&gt;</span> <span class="i">M</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs10', 289)" onmouseover="showTip(event, 'fs10', 289)" class="i">string</span><span class="o">&gt;</span> <span class="k">-&gt;</span> <span class="i">M</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs12', 290)" onmouseover="showTip(event, 'fs12', 290)" class="i">float</span><span class="o">&gt;</span> <span class="k">-&gt;</span> <span class="i">M</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'fs82', 291)" onmouseover="showTip(event, 'fs82', 291)" class="i">int</span><span class="o">&gt;</span>
</code></pre></td>
</tr>
</table>
<h3><code>return</code> or <code>retn</code></h3>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="o">&#39;</span><span class="i">a</span> <span class="k">-&gt;</span> <span class="i">M</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">a</span><span class="o">&gt;</span>
</code></pre></td>
</tr>
</table>
<p>It just boxes a <code>'a</code></p>
<h3><code>bind</code></h3>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp">(<span class="o">&#39;</span><span class="i">a</span> <span class="k">-&gt;</span> <span class="i">M</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">b</span><span class="o">&gt;</span>) <span class="k">-&gt;</span> <span class="i">M</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">a</span><span class="o">&gt;</span> <span class="k">-&gt;</span> <span class="i">M</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">b</span><span class="o">&gt;</span>
</code></pre></td>
</tr>
</table>
<p>Interpreted as a one-argument function, we can upgrade a function like <code>map</code>. The difference is
that we only upgrade the input, because the function we have already return a boxed value.</p>
<p>Interpreted as a two-argument function, we see it as a form of Continuation passing style. We
often use piping with <code>|&gt;</code> to get the value to the <em>left-side</em> and the continuation function on
the <em>right-side</em>.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">m</span> <span class="o">|&gt;</span> <span class="i">M</span><span class="o">.</span><span class="i">bind</span> <span class="i">f</span>
</code></pre></td>
</tr>
</table>
<p>On top, we give <code>|&gt; M.bind</code> it's own operator <code>&gt;&gt;=</code></p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">m</span> <span class="o">&gt;</span><span class="o">&gt;</span><span class="o">=</span> <span class="i">f</span>
</code></pre></td>
</tr>
</table>
<p>This way we have a boxed value <code>M&lt;'a&gt;</code>, but our function <code>f</code> only receives an unboxed <code>'a</code>. In this way
we can work with unboxed values and also use any function without explicitly box them. Because
we must return <em>boxed</em> values we usually use <code>return</code> to return/box an unboxed value inside of <code>f</code>.</p>
<p>The syntax of this kind of continuation-passing style can be improved with a <em>Computation Expression</em>.</p>
<h3>Implementations</h3>
<ul>
<li><code>map</code> can be implemented through <code>return</code> and <code>apply</code></li>
<li><code>map</code> can be implemented through <code>return</code> and <code>bind</code></li>
<li><code>apply</code> can be implemented through <code>return</code> and <code>bind</code></li>
<li><code>bind</code> can be implemented through <code>map</code> and some kind of <code>concat</code> operation</li>
</ul>


<div class="tip" id="fs1">module Main</div>
<div class="tip" id="fs2">namespace System</div>
<div class="tip" id="fs3">type Double =<br />&#160;&#160;struct<br />&#160;&#160;&#160;&#160;member CompareTo : value:obj -&gt; int + 1 overload<br />&#160;&#160;&#160;&#160;member Equals : obj:obj -&gt; bool + 1 overload<br />&#160;&#160;&#160;&#160;member GetHashCode : unit -&gt; int<br />&#160;&#160;&#160;&#160;member GetTypeCode : unit -&gt; TypeCode<br />&#160;&#160;&#160;&#160;member ToString : unit -&gt; string + 3 overloads<br />&#160;&#160;&#160;&#160;static val MinValue : float<br />&#160;&#160;&#160;&#160;static val MaxValue : float<br />&#160;&#160;&#160;&#160;static val Epsilon : float<br />&#160;&#160;&#160;&#160;static val NegativeInfinity : float<br />&#160;&#160;&#160;&#160;static val PositiveInfinity : float<br />&#160;&#160;&#160;&#160;...<br />&#160;&#160;end<br /><br />Full name: System.Double</div>
<div class="tip" id="fs4">static member Double.tryParse : str:string -&gt; float option<br /><br />Full name: Main.tryParse</div>
<div class="tip" id="fs5">val str : string</div>
<div class="tip" id="fs6">Double.TryParse(s: string, result: byref&lt;float&gt;) : bool<br />Double.TryParse(s: string, style: Globalization.NumberStyles, provider: IFormatProvider, result: byref&lt;float&gt;) : bool</div>
<div class="tip" id="fs7">union case Option.None: Option&lt;&#39;T&gt;</div>
<div class="tip" id="fs8">val x : float</div>
<div class="tip" id="fs9">union case Option.Some: Value: &#39;T -&gt; Option&lt;&#39;T&gt;</div>
<div class="tip" id="fs10">Multiple items<br />val string : value:&#39;T -&gt; string<br /><br />Full name: Microsoft.FSharp.Core.Operators.string<br /><br />--------------------<br />type string = System.String<br /><br />Full name: Microsoft.FSharp.Core.string</div>
<div class="tip" id="fs11">type &#39;T option = Option&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Core.option&lt;_&gt;</div>
<div class="tip" id="fs12">Multiple items<br />val float : value:&#39;T -&gt; float (requires member op_Explicit)<br /><br />Full name: Microsoft.FSharp.Core.Operators.float<br /><br />--------------------<br />type float = System.Double<br /><br />Full name: Microsoft.FSharp.Core.float<br /><br />--------------------<br />type float&lt;&#39;Measure&gt; = float<br /><br />Full name: Microsoft.FSharp.Core.float&lt;_&gt;</div>
<div class="tip" id="fs13">type &#39;T list = List&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Collections.list&lt;_&gt;</div>
<div class="tip" id="fs14">Multiple items<br />type Async<br />static member AsBeginEnd : computation:(&#39;Arg -&gt; Async&lt;&#39;T&gt;) -&gt; (&#39;Arg * AsyncCallback * obj -&gt; IAsyncResult) * (IAsyncResult -&gt; &#39;T) * (IAsyncResult -&gt; unit)<br />static member AwaitEvent : event:IEvent&lt;&#39;Del,&#39;T&gt; * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt; (requires delegate and &#39;Del :&gt; Delegate)<br />static member AwaitIAsyncResult : iar:IAsyncResult * ?millisecondsTimeout:int -&gt; Async&lt;bool&gt;<br />static member AwaitTask : task:Task -&gt; Async&lt;unit&gt;<br />static member AwaitTask : task:Task&lt;&#39;T&gt; -&gt; Async&lt;&#39;T&gt;<br />static member AwaitWaitHandle : waitHandle:WaitHandle * ?millisecondsTimeout:int -&gt; Async&lt;bool&gt;<br />static member CancelDefaultToken : unit -&gt; unit<br />static member Catch : computation:Async&lt;&#39;T&gt; -&gt; Async&lt;Choice&lt;&#39;T,exn&gt;&gt;<br />static member FromBeginEnd : beginAction:(AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member FromBeginEnd : arg:&#39;Arg1 * beginAction:(&#39;Arg1 * AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member FromBeginEnd : arg1:&#39;Arg1 * arg2:&#39;Arg2 * beginAction:(&#39;Arg1 * &#39;Arg2 * AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member FromBeginEnd : arg1:&#39;Arg1 * arg2:&#39;Arg2 * arg3:&#39;Arg3 * beginAction:(&#39;Arg1 * &#39;Arg2 * &#39;Arg3 * AsyncCallback * obj -&gt; IAsyncResult) * endAction:(IAsyncResult -&gt; &#39;T) * ?cancelAction:(unit -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member FromContinuations : callback:((&#39;T -&gt; unit) * (exn -&gt; unit) * (OperationCanceledException -&gt; unit) -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member Ignore : computation:Async&lt;&#39;T&gt; -&gt; Async&lt;unit&gt;<br />static member OnCancel : interruption:(unit -&gt; unit) -&gt; Async&lt;IDisposable&gt;<br />static member Parallel : computations:seq&lt;Async&lt;&#39;T&gt;&gt; -&gt; Async&lt;&#39;T []&gt;<br />static member RunSynchronously : computation:Async&lt;&#39;T&gt; * ?timeout:int * ?cancellationToken:CancellationToken -&gt; &#39;T<br />static member Sleep : millisecondsDueTime:int -&gt; Async&lt;unit&gt;<br />static member Start : computation:Async&lt;unit&gt; * ?cancellationToken:CancellationToken -&gt; unit<br />static member StartAsTask : computation:Async&lt;&#39;T&gt; * ?taskCreationOptions:TaskCreationOptions * ?cancellationToken:CancellationToken -&gt; Task&lt;&#39;T&gt;<br />static member StartChild : computation:Async&lt;&#39;T&gt; * ?millisecondsTimeout:int -&gt; Async&lt;Async&lt;&#39;T&gt;&gt;<br />static member StartChildAsTask : computation:Async&lt;&#39;T&gt; * ?taskCreationOptions:TaskCreationOptions -&gt; Async&lt;Task&lt;&#39;T&gt;&gt;<br />static member StartImmediate : computation:Async&lt;unit&gt; * ?cancellationToken:CancellationToken -&gt; unit<br />static member StartWithContinuations : computation:Async&lt;&#39;T&gt; * continuation:(&#39;T -&gt; unit) * exceptionContinuation:(exn -&gt; unit) * cancellationContinuation:(OperationCanceledException -&gt; unit) * ?cancellationToken:CancellationToken -&gt; unit<br />static member SwitchToContext : syncContext:SynchronizationContext -&gt; Async&lt;unit&gt;<br />static member SwitchToNewThread : unit -&gt; Async&lt;unit&gt;<br />static member SwitchToThreadPool : unit -&gt; Async&lt;unit&gt;<br />static member TryCancelled : computation:Async&lt;&#39;T&gt; * compensation:(OperationCanceledException -&gt; unit) -&gt; Async&lt;&#39;T&gt;<br />static member CancellationToken : Async&lt;CancellationToken&gt;<br />static member DefaultCancellationToken : CancellationToken<br /><br />Full name: Microsoft.FSharp.Control.Async<br /><br />--------------------<br />type Async&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Control.Async&lt;_&gt;</div>
<div class="tip" id="fs15">val mapOption : f:(&#39;a -&gt; &#39;b) -&gt; opt:&#39;a option -&gt; &#39;b option<br /><br />Full name: Main.mapOption</div>
<div class="tip" id="fs16">val f : (&#39;a -&gt; &#39;b)</div>
<div class="tip" id="fs17">val opt : &#39;a option</div>
<div class="tip" id="fs18">val x : &#39;a</div>
<div class="tip" id="fs19">val bindOption : f:(&#39;a -&gt; &#39;b option) -&gt; opt:&#39;a option -&gt; &#39;b option<br /><br />Full name: Main.bindOption</div>
<div class="tip" id="fs20">val f : (&#39;a -&gt; &#39;b option)</div>
<div class="tip" id="fs21">val joinOption : opt:&#39;a option option -&gt; &#39;a option<br /><br />Full name: Main.joinOption</div>
<div class="tip" id="fs22">val opt : &#39;a option option</div>
<div class="tip" id="fs23">val innerOpt : &#39;a option</div>
<div class="tip" id="fs24">val bindOption2 : f:(&#39;a -&gt; &#39;b option) -&gt; opt:&#39;a option -&gt; &#39;b option<br /><br />Full name: Main.bindOption2</div>
<div class="tip" id="fs25">val input1 : float option<br /><br />Full name: Main.input1</div>
<div class="tip" id="fs26">static member Double.tryParse : str:string -&gt; float option</div>
<div class="tip" id="fs27">val input2 : float option<br /><br />Full name: Main.input2</div>
<div class="tip" id="fs28">val input3 : float option option<br /><br />Full name: Main.input3</div>
<div class="tip" id="fs29">val mapList : f:(&#39;a -&gt; &#39;b) -&gt; inputList:&#39;a list -&gt; &#39;b list<br /><br />Full name: Main.mapList</div>
<div class="tip" id="fs30">val inputList : &#39;a list</div>
<div class="tip" id="fs31">val folder : (&#39;a -&gt; &#39;b list -&gt; &#39;b list)</div>
<div class="tip" id="fs32">val xs : &#39;b list</div>
<div class="tip" id="fs33">Multiple items<br />module List<br /><br />from Microsoft.FSharp.Collections<br /><br />--------------------<br />type List&lt;&#39;T&gt; =<br />&#160;&#160;| ( [] )<br />&#160;&#160;| ( :: ) of Head: &#39;T * Tail: &#39;T list<br />&#160;&#160;interface IEnumerable<br />&#160;&#160;interface IEnumerable&lt;&#39;T&gt;<br />&#160;&#160;member GetSlice : startIndex:int option * endIndex:int option -&gt; &#39;T list<br />&#160;&#160;member Head : &#39;T<br />&#160;&#160;member IsEmpty : bool<br />&#160;&#160;member Item : index:int -&gt; &#39;T with get<br />&#160;&#160;member Length : int<br />&#160;&#160;member Tail : &#39;T list<br />&#160;&#160;static member Cons : head:&#39;T * tail:&#39;T list -&gt; &#39;T list<br />&#160;&#160;static member Empty : &#39;T list<br /><br />Full name: Microsoft.FSharp.Collections.List&lt;_&gt;</div>
<div class="tip" id="fs34">val foldBack : folder:(&#39;T -&gt; &#39;State -&gt; &#39;State) -&gt; list:&#39;T list -&gt; state:&#39;State -&gt; &#39;State<br /><br />Full name: Microsoft.FSharp.Collections.List.foldBack</div>
<div class="tip" id="fs35">val bindList : f:(&#39;a -&gt; &#39;b list) -&gt; xs:&#39;a list -&gt; &#39;b list<br /><br />Full name: Main.bindList</div>
<div class="tip" id="fs36">val f : (&#39;a -&gt; &#39;b list)</div>
<div class="tip" id="fs37">val xs : &#39;a list</div>
<div class="tip" id="fs38">val map : mapping:(&#39;T -&gt; &#39;U) -&gt; list:&#39;T list -&gt; &#39;U list<br /><br />Full name: Microsoft.FSharp.Collections.List.map</div>
<div class="tip" id="fs39">val concat : lists:seq&lt;&#39;T list&gt; -&gt; &#39;T list<br /><br />Full name: Microsoft.FSharp.Collections.List.concat</div>
<div class="tip" id="fs40">val m : &#39;a option</div>
<div class="tip" id="fs41">module Option<br /><br />from Microsoft.FSharp.Core</div>
<div class="tip" id="fs42">val bind : binder:(&#39;T -&gt; &#39;U option) -&gt; option:&#39;T option -&gt; &#39;U option<br /><br />Full name: Microsoft.FSharp.Core.Option.bind</div>
<div class="tip" id="fs43">val getUserInput : msg:string -&gt; float option<br /><br />Full name: Main.getUserInput</div>
<div class="tip" id="fs44">val msg : string</div>
<div class="tip" id="fs45">val printfn : format:Printf.TextWriterFormat&lt;&#39;T&gt; -&gt; &#39;T<br /><br />Full name: Microsoft.FSharp.Core.ExtraTopLevelOperators.printfn</div>
<div class="tip" id="fs46">type Console =<br />&#160;&#160;static member BackgroundColor : ConsoleColor with get, set<br />&#160;&#160;static member Beep : unit -&gt; unit + 1 overload<br />&#160;&#160;static member BufferHeight : int with get, set<br />&#160;&#160;static member BufferWidth : int with get, set<br />&#160;&#160;static member CapsLock : bool<br />&#160;&#160;static member Clear : unit -&gt; unit<br />&#160;&#160;static member CursorLeft : int with get, set<br />&#160;&#160;static member CursorSize : int with get, set<br />&#160;&#160;static member CursorTop : int with get, set<br />&#160;&#160;static member CursorVisible : bool with get, set<br />&#160;&#160;...<br /><br />Full name: System.Console</div>
<div class="tip" id="fs47">Console.ReadLine() : string</div>
<div class="tip" id="fs48">val someInput : float option<br /><br />Full name: Main.someInput</div>
<div class="tip" id="fs49">val retn : x:&#39;a -&gt; &#39;a option<br /><br />Full name: Main.retn</div>
<div class="tip" id="fs50">val circleArea : r:float -&gt; float<br /><br />Full name: Main.circleArea</div>
<div class="tip" id="fs51">val r : float</div>
<div class="tip" id="fs52">type Math =<br />&#160;&#160;static val PI : float<br />&#160;&#160;static val E : float<br />&#160;&#160;static member Abs : value:sbyte -&gt; sbyte + 6 overloads<br />&#160;&#160;static member Acos : d:float -&gt; float<br />&#160;&#160;static member Asin : d:float -&gt; float<br />&#160;&#160;static member Atan : d:float -&gt; float<br />&#160;&#160;static member Atan2 : y:float * x:float -&gt; float<br />&#160;&#160;static member BigMul : a:int * b:int -&gt; int64<br />&#160;&#160;static member Ceiling : d:decimal -&gt; decimal + 1 overload<br />&#160;&#160;static member Cos : d:float -&gt; float<br />&#160;&#160;...<br /><br />Full name: System.Math</div>
<div class="tip" id="fs53">field Math.PI = 3.14159265359</div>
<div class="tip" id="fs54">val area : float option<br /><br />Full name: Main.area</div>
<div class="tip" id="fs55">val userInput : float</div>
<div class="tip" id="fs56">val area : float</div>
<div class="tip" id="fs57">val cubeVolume : float option<br /><br />Full name: Main.cubeVolume</div>
<div class="tip" id="fs58">val y : float</div>
<div class="tip" id="fs59">val z : float</div>
<div class="tip" id="fs60">val volume : float</div>
<div class="tip" id="fs61">Multiple items<br />type MaybeBuilder =<br />&#160;&#160;new : unit -&gt; MaybeBuilder<br />&#160;&#160;member Bind : m:&#39;b option * f:(&#39;b -&gt; &#39;c option) -&gt; &#39;c option<br />&#160;&#160;member Return : x:&#39;a -&gt; &#39;a option<br /><br />Full name: Main.MaybeBuilder<br /><br />--------------------<br />new : unit -&gt; MaybeBuilder</div>
<div class="tip" id="fs62">val o : MaybeBuilder</div>
<div class="tip" id="fs63">member MaybeBuilder.Bind : m:&#39;b option * f:(&#39;b -&gt; &#39;c option) -&gt; &#39;c option<br /><br />Full name: Main.MaybeBuilder.Bind</div>
<div class="tip" id="fs64">val m : &#39;b option</div>
<div class="tip" id="fs65">val f : (&#39;b -&gt; &#39;c option)</div>
<div class="tip" id="fs66">member MaybeBuilder.Return : x:&#39;a -&gt; &#39;a option<br /><br />Full name: Main.MaybeBuilder.Return</div>
<div class="tip" id="fs67">val maybe : MaybeBuilder<br /><br />Full name: Main.maybe</div>
<div class="tip" id="fs68">val cubeVolume2 : float option<br /><br />Full name: Main.cubeVolume2</div>
<div class="tip" id="fs69">val vol : float</div>
<div class="tip" id="fs70">val map : f:(&#39;a -&gt; &#39;b) -&gt; opt:&#39;a option -&gt; &#39;b option<br /><br />Full name: Main.map</div>
<div class="tip" id="fs71">val apply : fo:(&#39;a -&gt; &#39;b) option -&gt; xo:&#39;a option -&gt; &#39;b option<br /><br />Full name: Main.apply</div>
<div class="tip" id="fs72">val fo : (&#39;a -&gt; &#39;b) option</div>
<div class="tip" id="fs73">val xo : &#39;a option</div>
<div class="tip" id="fs74">val g : (&#39;b -&gt; &#39;c)</div>
<div class="tip" id="fs75">val g : (&#39;b -&gt; &#39;c option)</div>
<div class="tip" id="fs76">val f : arg00:string -&gt; float option<br /><br />Full name: Main.f</div>
<div class="tip" id="fs77">val g : x:float -&gt; float option<br /><br />Full name: Main.g</div>
<div class="tip" id="fs78">val x : string<br /><br />Full name: Main.x</div>
<div class="tip" id="fs79">val m : string option<br /><br />Full name: Main.m</div>
<div class="tip" id="fs80">val ax : float option<br /><br />Full name: Main.ax</div>
<div class="tip" id="fs81">val ay : float option<br /><br />Full name: Main.ay</div>
<div class="tip" id="fs82">Multiple items<br />val int : value:&#39;T -&gt; int (requires member op_Explicit)<br /><br />Full name: Microsoft.FSharp.Core.Operators.int<br /><br />--------------------<br />type int = int32<br /><br />Full name: Microsoft.FSharp.Core.int<br /><br />--------------------<br />type int&lt;&#39;Measure&gt; = int<br /><br />Full name: Microsoft.FSharp.Core.int&lt;_&gt;</div>
